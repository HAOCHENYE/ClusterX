# Code generated by Claude. Maybe need to refine...
import asyncio
from collections import deque
from typing import AsyncIterator

from prompt_toolkit.application import Application
from prompt_toolkit.formatted_text import ANSI
from prompt_toolkit.key_binding import KeyBindings, KeyPressEvent
from prompt_toolkit.layout.containers import HSplit, Window
from prompt_toolkit.layout.controls import FormattedTextControl
from prompt_toolkit.layout.dimension import Dimension
from prompt_toolkit.layout.layout import Layout


class Pager:
    def __init__(self, content_iterator: AsyncIterator[str]):
        self.content_iterator = content_iterator
        self.content_buffer: deque[str] = deque()  # 用于存储已读取的内容
        self.current_line = 0
        self.page_size = 20
        self.is_eof = False
        self.update_event = asyncio.Event()

        # 创建键绑定
        self.kb = KeyBindings()
        self.setup_keybindings()

        # 创建主窗口
        self.main_window = Window(
            content=FormattedTextControl(self.get_content), wrap_lines=True, height=Dimension(preferred=self.page_size)
        )

        # 创建状态栏
        self.status_window = Window(content=FormattedTextControl(self.get_status), height=1)

        # 创建布局
        self.container = HSplit([self.main_window, self.status_window])

        # 创建应用
        self.app = Application(
            layout=Layout(self.container),
            key_bindings=self.kb,
            full_screen=True,
            mouse_support=True,
            refresh_interval=0.1,  # 每0.1秒刷新一次界面
        )

    async def content_reader(self):
        """异步读取内容的后台任务."""
        try:
            async for line in self.content_iterator:
                self.content_buffer.append(line.rstrip())
                self.update_event.set()  # 通知有新内容
                await asyncio.sleep(0)  # 让出控制权
        except StopAsyncIteration:
            self.is_eof = True
        finally:
            self.update_event.set()

    def get_page_size(self):
        """获取当前窗口的实际可显示行数."""
        if self.app and self.app.output:
            return max(1, self.app.output.get_size().rows - 2)
        return self.page_size

    def setup_keybindings(self):
        @self.kb.add("q")
        def _(event):
            event.app.exit()

        @self.kb.add("j")
        @self.kb.add("down")
        def _(event: KeyPressEvent):
            if self.current_line < len(self.content_buffer) - 1:
                self.current_line += 1

        @self.kb.add("k")
        @self.kb.add("up")
        def _(event):
            self.current_line = max(0, self.current_line - 1)

        @self.kb.add("pagedown")
        @self.kb.add("c-d")
        @self.kb.add("c-f")
        @self.kb.add("space")
        def _(event):
            page_size = self.get_page_size()
            if self.current_line + page_size < len(self.content_buffer):
                self.current_line += page_size
            else:
                self.current_line = max(0, len(self.content_buffer) - 1)

        @self.kb.add("pageup")
        @self.kb.add("c-b")
        @self.kb.add("c-u")
        @self.kb.add("b")
        def _(event):
            page_size = self.get_page_size()
            self.current_line = max(0, self.current_line - page_size)

        @self.kb.add("g")
        def _(event):
            self.current_line = 0

        @self.kb.add("G")
        def _(event):
            if self.content_buffer:
                self.current_line = len(self.content_buffer) - 1

    def get_content(self):
        """获取当前页显示的内容."""
        page_size = self.get_page_size()
        visible_lines = list(self.content_buffer)[self.current_line : self.current_line + page_size]

        # 如果内容不足一页且还没有读到文件末尾，添加等待提示
        if len(visible_lines) < page_size and not self.is_eof:
            visible_lines.append("Loading more content...")

        return ANSI("\n".join(visible_lines))

    def get_status(self):
        """获取状态栏内容."""
        total_lines = len(self.content_buffer)
        progress = min(100, int((self.current_line + 1) * 100 / max(1, total_lines)))
        status = f"Line {self.current_line + 1} of {total_lines}"
        if not self.is_eof:
            status += " (Loading...)"
        return ANSI(f"\033[32m{status} ({progress}%) Press q to quit\033[0m")

    async def run(self):
        """异步运行分页器."""
        # 启动内容读取任务
        reader_task = asyncio.create_task(self.content_reader())

        # 运行应用
        await self.app.run_async()

        # 清理
        reader_task.cancel()
        try:
            await reader_task
        except asyncio.CancelledError:
            pass
